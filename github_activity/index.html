<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Activity Dashboard</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Chart.js for charting -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- Load Chart.js Datalabels Plugin for showing numbers on the chart -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.2.0/dist/chartjs-plugin-datalabels.min.js"></script>
    <!-- Load html2canvas for capturing charts as images -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        /* Custom styles for a light, professional look */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Very light gray background */
            color: #1f2937; /* Dark gray text */
            min-height: 100vh;
        }
        .card {
            background-color: #ffffff; /* White card background */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        /* Style for the modal overlay */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #ffffff;
            max-height: 90vh;
            overflow-y: auto;
        }
        /* Ensure the chart columns have enough height */
        @media (min-width: 1024px) {
            .chart-col {
                min-height: 350px; /* Ensure columns have a minimum height for all charts */
            }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <header class="mb-8 text-center">
        <h1 class="text-4xl font-extrabold text-blue-700">GitHub Activity Dashboard</h1>
        <p class="text-gray-600 mt-2">Visualize your Pull Request contributions and discussion volume for any selected year.</p>
    </header>

    <div class="max-w-7xl mx-auto space-y-8"> 
        <!-- Input Form Card -->
        <div class="card p-6 rounded-xl">
            <h2 class="text-2xl font-semibold mb-4 border-b border-gray-300 pb-2 text-blue-600">Configuration</h2>
            <div class="grid grid-cols-1 md:grid-cols-5 gap-4 items-end"> 
                <div class="col-span-1">
                    <label for="pat" class="block text-sm font-medium mb-1 text-gray-700 flex justify-between items-center">
                        GitHub PAT (Read Access)
                        <svg onclick="showPatInfoModal()" class="w-4 h-4 text-blue-500 cursor-pointer hover:text-blue-700 transition" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clip-rule="evenodd"></path>
                        </svg>
                    </label>
                    <input type="password" id="pat" placeholder="github_pat_..." class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="col-span-1">
                    <label for="username" class="block text-sm font-medium mb-1 text-gray-700">GitHub Username</label>
                    <input type="text" id="username" value="" placeholder="username" class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div class="col-span-1">
                    <label for="yearSelector" class="block text-sm font-medium mb-1 text-gray-700">Year</label>
                    <select id="yearSelector" class="w-full px-3 py-2 rounded-lg bg-white border border-gray-300 text-gray-900 focus:ring-blue-500 focus:border-blue-500">
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <div class="col-span-1">
                    <button id="generateBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:bg-gray-400" onclick="generateDashboard()">
                        Generate Dashboard
                    </button>
                </div>
                <div class="col-span-1">
                    <button id="downloadBtn" class="w-full bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded-lg transition duration-150 ease-in-out disabled:bg-gray-400 hidden" onclick="downloadDashboardReport()">
                        Download Report
                    </button>
                </div>
            </div>
            <p id="rateLimit" class="text-xs text-gray-500 mt-3 text-right hidden">Rate Limit: <span id="rateRemaining"></span> remaining.</p>
        </div>

        <!-- Dashboard Output Area -->
        <div id="dashboardArea" class="hidden">
            <h2 id="summaryTitle" class="text-2xl font-semibold mb-4 text-blue-600">Activity Summary</h2> 
            
            <!-- Five Charts (Grid) - Now arranged in 2 columns -->
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-8 mb-8">
                
                <!-- Chart 1: PRs Authored vs Reviewed (Pie Chart) - CLICKABLE -->
                <div class="card p-6 rounded-xl chart-col">
                    <div class="relative max-w-full mx-auto h-72 cursor-pointer mb-6" onclick="handleChartClickWrapper(event, prChart)"> 
                        <canvas id="prPieChart"></canvas>
                    </div>
                    <p id="totalSummary" class="text-center text-gray-700 mt-4 text-lg font-medium"></p>
                </div>
                
                <!-- Chart 2: PRs Authored Languages (Pie Chart) - CLICKABLE -->
                <div class="card p-6 rounded-xl chart-col">
                    <div class="relative max-w-full mx-auto h-72 cursor-pointer mb-6" onclick="handleChartClickWrapper(event, languageChart)"> 
                        <canvas id="languagePieChart"></canvas>
                    </div>
                    <p id="languageSummary" class="text-center text-gray-700 mt-4 text-lg font-medium"></p>
                </div>
                
                <!-- Chart 3: PRs Reviewed Languages (Pie Chart) - CLICKABLE -->
                <div class="card p-6 rounded-xl chart-col">
                    <div class="relative max-w-full mx-auto h-72 cursor-pointer mb-6" onclick="handleChartClickWrapper(event, reviewedLanguageChart)"> 
                        <canvas id="reviewedLanguagePieChart"></canvas>
                    </div>
                    <p id="reviewedLanguageSummary" class="text-center text-gray-700 mt-4 text-lg font-medium"></p>
                </div>

                <!-- Chart 5: Reviewed Autogenerated PRs Language Breakdown (NEW PIE CHART) - CLICKABLE -->
                <div class="card p-6 rounded-xl chart-col">
                    <div class="relative max-w-full mx-auto h-72 cursor-pointer mb-6" onclick="handleChartClickWrapper(event, reviewedBotLanguageChart)"> 
                        <canvas id="reviewedBotLanguagePieChart"></canvas>
                    </div>
                    <p id="reviewedBotLanguageSummary" class="text-center text-gray-700 mt-4 text-lg font-medium"></p>
                </div>

                <!-- Chart 4: PRs Discussion Volume (Bar Chart) - CLICKABLE (Authored only) -->
                <div class="card p-6 rounded-xl chart-col">
                    <div class="relative max-w-full mx-auto h-72 cursor-pointer mb-6" onclick="handleChartClickWrapper(event, commentChart)"> 
                        <canvas id="commentBarChart"></canvas>
                    </div>
                    <p id="commentSummary" class="text-center text-gray-700 mt-4 text-lg font-medium"></p>
                </div>
                
            </div>
            
            <!-- Table Container Grid -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Column 1: Overall Contribution Totals Table -->
                <div class="col-span-1 max-w-xl mx-auto lg:mx-0">
                    <div class="card p-6 rounded-xl"> 
                        <h3 class="text-xl font-semibold mb-4 text-blue-600 border-b pb-2">Overall Contribution Totals</h3>
                        <div id="overallTotalsTable">
                            <!-- Content will be rendered here -->
                        </div>
                    </div>
                </div>

                <!-- Column 2: New Commit Contributions Table -->
                <div class="col-span-1 max-w-xl mx-auto lg:mx-0">
                    <div class="card p-6 rounded-xl">
                        <h3 class="text-xl font-semibold mb-4 text-blue-600 border-b pb-2">Commit Contributions (Top 50 Repos)</h3>
                        <div id="repoCommitTable">
                            <!-- Content will be rendered here -->
                        </div>
                    </div>
                </div>
            </div>

        </div>

        <!-- Message/Error Box -->
        <div id="messageBox" class="hidden p-4 rounded-lg text-center text-white" role="alert">
            <p id="messageText" class="font-medium"></p>
        </div>
    </div>
    
    <!-- PR List Modal - Reused for Commits -->
    <div id="prListModal" class="modal-overlay hidden">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-1/2 p-6 rounded-xl shadow-2xl">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="modalTitle" class="2xl font-bold text-gray-800">Details List</h3>
                <button onclick="closeModal('prListModal')" class="text-gray-500 hover:text-gray-700 text-3xl font-light leading-none">&times;</button>
            </div>
            <div id="prListContainer" class="space-y-4">
                <!-- PR or Commit items will be injected here -->
            </div>
            <div class="mt-6 text-right">
                <button onclick="closeModal('prListModal')" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition duration-150">Close</button>
            </div>
        </div>
    </div>

    <!-- PAT Info Modal -->
    <div id="patInfoModal" class="modal-overlay hidden">
        <div class="modal-content w-11/12 md:w-3/4 lg:w-1/2 p-6 rounded-xl shadow-2xl">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 class="text-2xl font-bold text-gray-800">GitHub Personal Access Token Instructions</h3>
                <button onclick="closeModal('patInfoModal')" class="text-gray-500 hover:text-gray-700 text-3xl font-light leading-none">&times;</button>
            </div>
            <div class="text-gray-700 space-y-4">
                <p>A Personal Access Token (PAT) is required to access your private GitHub activity through the API.</p>
                <p>Please follow these steps to create a new token:</p>
                
                <ol class="list-decimal list-inside space-y-2 ml-4">
                    <li>Go to the <a href="https://github.com/settings/personal-access-tokens" target="_blank" class="text-blue-600 hover:underline font-medium">GitHub Personal Access Tokens page</a> and click <strong>Generate new token</strong>.</li>
                    <li>Choose <strong>Fine-grained tokens</strong>.</li>
                    <li>
                        <strong>Token Details:</strong>
                        <ul class="list-disc list-inside ml-6 text-sm">
                            <li><strong>Token name:</strong> `Dashboard-Access` (or similar)</li>
                            <li><strong>Expiration:</strong> Set to <strong>1 day</strong> to avoid reuse.</li>
                            <li><strong>Resource owner:</strong> Your username</li>
                        </ul>
                    </li>
                    <li>
                        <strong>Permissions (Crucial Step):</strong>
                        <ul class="list-disc list-inside ml-6 text-sm">
                            <li>Set <strong>Account permissions</strong> to <strong>Read-only</strong> for <strong>Metadata</strong>.</li>
                            <li>Set <strong>Repository permissions</strong> to <strong>Read-only</strong> for <strong>Contents</strong>.</li>
                            <li>Set <strong>Repository permissions</strong> to <strong>Read-only</strong> for <strong>Pull requests</strong>.</li>
                        </ul>
                    </li>
                    <li>Click <strong>Generate token</strong> and paste the resulting key into the input field above.</li>
                </ol>
                <p class="text-red-600 font-medium"><strong>Security Warning:</strong> This token will only be visible once. Treat it like a password and do not share it.</p>
            </div>
            <div class="mt-6 text-right">
                <button onclick="closeModal('patInfoModal')" class="bg-gray-200 hover:bg-gray-300 text-gray-800 font-bold py-2 px-4 rounded-lg transition duration-150">Close</button>
            </div>
        </div>
    </div>

    <script>
        // NOTE: ChartDataLabels registration moved into chart configs

        // GLOBAL CONSTANT: Maximum number of PRs to fetch per page during pagination
        const PR_PAGE_SIZE = 100;

        // BOT IDENTIFIERS
        const BOT_USERNAMES = [
            'renovate-bot', 'cloud-java-bot', 'cloud-sdk-librarian-robot', 'gcf-owl-bot', 'release-please', 'dependabot'
        ];

        const patInput = document.getElementById('pat');
        const usernameInput = document.getElementById('username');
        const yearSelector = document.getElementById('yearSelector');
        const generateBtn = document.getElementById('generateBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const dashboardArea = document.getElementById('dashboardArea');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const totalSummary = document.getElementById('totalSummary');
        const languageSummary = document.getElementById('languageSummary');
        const reviewedLanguageSummary = document.getElementById('reviewedLanguageSummary');
        const reviewedBotLanguageSummary = document.getElementById('reviewedBotLanguageSummary'); // NEW SUMMARY
        const summaryTitle = document.getElementById('summaryTitle');
        const rateLimitDisplay = document.getElementById('rateLimit');
        const rateRemainingDisplay = document.getElementById('rateRemaining');
        const prListModal = document.getElementById('prListModal');
        const modalTitle = document.getElementById('modalTitle');
        const prListContainer = document.getElementById('prListContainer');
        
        // NEW chart summary element
        const commentSummary = document.getElementById('commentSummary');
        
        // NEW chart instance for bots
        let reviewedBotLanguageChart = null; 
        
        // NEW chart instance for bots
        const reviewedBotLanguagePieChart = document.getElementById('reviewedBotLanguagePieChart');
        
        // NEW table containers
        const overallTotalsTable = document.getElementById('overallTotalsTable');
        const repoCommitTable = document.getElementById('repoCommitTable'); 
        const patInfoModal = document.getElementById('patInfoModal');
        
        let prChart = null;
        let languageChart = null;
        let reviewedLanguageChart = null;
        let commentChart = null; 
        
        let prDataCache = { 
            authored: [], 
            reviewedHuman: [], 
            reviewedBot: []   
        }; 

        // --- Utility Functions ---

        /**
         * Shows a message to the user (instead of alert()).
         * @param {string} text The message text.
         * @param {string} type 'success', 'error', or 'info'.
         */
        function showMessage(text, type = 'info') {
            messageBox.classList.remove('hidden', 'bg-red-600', 'bg-green-600', 'bg-blue-600');
            messageText.textContent = text;
            messageBox.classList.add('text-white');

            let bgColor = 'bg-blue-600';
            if (type === 'error') bgColor = 'bg-red-600';
            if (type === 'success') bgColor = 'bg-green-600';

            messageBox.classList.add(bgColor);
        }

        /**
         * Clears the message box.
         */
        function clearMessage() {
            messageBox.classList.add('hidden');
            messageBox.classList.remove('bg-red-600', 'bg-green-600', 'bg-blue-600');
            messageText.textContent = '';
        }

        /**
         * Populates the year selector dropdown.
         */
        function populateYearSelector() {
            const currentYear = new Date().getFullYear();
            const startYear = 2018; 

            for (let year = currentYear; year >= startYear; year--) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === currentYear) {
                    option.selected = true;
                }
                yearSelector.appendChild(option);
            }
        }

        /**
         * Calculates the start and end dates/datetimes for the target year.
         * @param {number} targetYear The year to generate dates for.
         * @returns {{dateOnlyStart: string, dateOnlyEnd: string, dateTimeStart: string, dateTimeEnd: string}}
         */
        function getCurrentYearDates(targetYear) {
            const TARGET_YEAR = targetYear; 

            // 1. For GitHub search syntax (YYYY-MM-DD..YYYY-MM-DD)
            const dateOnlyStart = `${TARGET_YEAR}-01-01`; 
            const dateOnlyEnd = `${TARGET_YEAR}-12-31`; 

            // 2. For GraphQL DateTime fields (e.g., contributionsCollection)
            // Uses UTC midnight to ensure the correct range boundaries.
            const dateTimeStart = new Date(Date.UTC(TARGET_YEAR, 0, 1)).toISOString(); // Jan 1st 00:00:00Z
            const dateTimeEnd = new Date(Date.UTC(TARGET_YEAR, 11, 31, 23, 59, 59)).toISOString(); // Dec 31st 23:59:59Z

            return {
                dateOnlyStart: dateOnlyStart,
                dateOnlyEnd: dateOnlyEnd,
                dateTimeStart: dateTimeStart,
                dateTimeEnd: dateTimeEnd
            };
        }
        
        /**
         * Generates an array of monthly date ranges (start/end) for a given year.
         * Used to split high-volume search queries into manageable chunks.
         * @param {number} year 
         * @returns {Array<{start: string, end: string}>}
         */
        function getMonthlyDateRanges(year) {
            const ranges = [];
            for (let month = 0; month < 12; month++) {
                // Start of the month
                const dateStart = new Date(year, month, 1);
                // End of the month (Start of next month minus 1 millisecond)
                const dateEnd = new Date(year, month + 1, 1);
                dateEnd.setMilliseconds(-1);

                const formatDate = (d) => {
                    return `${d.getFullYear()}-${(d.getMonth() + 1).toString().padStart(2, '0')}-${d.getDate().toString().padStart(2, '0')}`;
                };

                ranges.push({
                    start: formatDate(dateStart),
                    end: formatDate(dateEnd)
                });
            }
            return ranges;
        }

        /**
         * Converts ISO date string to a readable local format.
         */
        function formatReadableDate(isoString) {
            const date = new Date(isoString);
            return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
        }
        
        /**
         * Processes the PR edges to count primary languages.
         */
        function processLanguageData(prEdges) {
            const languageCounts = {};
            prEdges.forEach(pr => {
                const language = pr.node.repository?.primaryLanguage?.name || 'No Primary Language';
                languageCounts[language] = (languageCounts[language] || 0) + 1;
            });
            return languageCounts;
        }

        /**
         * Processes PR edges to group review thread counts into specified buckets (0, 1-5, 6-10, etc.)
         */
        function processCommentDistribution(prEdges) {
            // Define buckets up to 20, plus a bucket for >20
            const buckets = {
                '0': 0, 
                '1-5': 0, 
                '6-10': 0, 
                '11-15': 0, 
                '16-20': 0, 
                '20+': 0
            };

            const bucketLabels = Object.keys(buckets);
            let totalPRsAnalyzed = 0;

            prEdges.forEach(pr => {
                const node = pr.node;
                
                // Use the correct field: reviewThreads count
                const reviewThreadCount = node.reviewThreads ? node.reviewThreads.totalCount : 0;
                
                const replyCount = reviewThreadCount; // Using thread count as a proxy for discussion/reply volume
                
                totalPRsAnalyzed++;

                if (replyCount === 0) {
                    buckets['0']++;
                } else if (replyCount >= 1 && replyCount <= 5) {
                    buckets['1-5']++;
                } else if (replyCount >= 6 && replyCount <= 10) {
                    buckets['6-10']++;
                } else if (replyCount >= 11 && replyCount <= 15) {
                    buckets['11-15']++;
                } else if (replyCount >= 16 && replyCount <= 20) {
                    buckets['16-20']++;
                } else {
                    buckets['20+']++;
                }
            });

            return {
                labels: bucketLabels,
                counts: bucketLabels.map(label => buckets[label]),
                totalPRsAnalyzed: totalPRsAnalyzed
            };
        }
        
        /**
         * Splits reviewed PR edges into human and bot categories.
         * @param {Array<Object>} reviewedEdges All PR edges reviewed by the user.
         * @returns {{reviewedHuman: Array<Object>, reviewedBot: Array<Object>}}
         */
        function splitReviewedPrs(reviewedEdges) {
            const reviewedHuman = [];
            const reviewedBot = [];

            reviewedEdges.forEach(pr => {
                const authorLogin = pr.node.author?.login || '';
                
                if (BOT_USERNAMES.includes(authorLogin.toLowerCase())) {
                    reviewedBot.push(pr);
                } else {
                    reviewedHuman.push(pr);
                }
            });

            return { reviewedHuman, reviewedBot };
        }


        // --- GitHub API Interaction ---

        const GITHUB_GRAPHQL_ENDPOINT = 'https://api.github.com/graphql';

        /**
         * Generic fetcher function for GraphQL.
         */
        async function runGraphQLQuery(token, query, variables = {}) {
            const headers = {
                'Authorization': `bearer ${token}`,
                'Content-Type': 'application/json'
            };

            const payload = { 
                query,
                variables 
            };
            
            // Exponential backoff for retries (max 3 times)
            for (let i = 0; i < 3; i++) {
                try {
                    const response = await fetch(GITHUB_GRAPHQL_ENDPOINT, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 401) {
                        throw new Error("GitHub API HTTP error: 401 Unauthorized. Please check your PAT validity and read:user scope.");
                    }
                    if (!response.ok) {
                        throw new Error(`GitHub API HTTP error: ${response.status} ${response.statusText}`);
                    }

                    const data = await response.json();

                    if (data.errors) {
                        const errorMessages = data.errors.map(err => err.message).join('; ');
                        throw new Error(`GitHub API GraphQL Error: ${errorMessages}`);
                    }

                    return data.data; // Success, break loop and return
                } catch (error) {
                    if (i < 2) {
                        const delay = Math.pow(2, i) * 1000;
                        console.warn(`Attempt ${i + 1} failed. Retrying in ${delay}ms...`, error.message);
                        await new Promise(resolve => setTimeout(resolve, delay));
                    } else {
                        throw error; // Last attempt failed
                    }
                }
            }
        }
        
        /**
         * Fetches a complete set of PRs using pagination for a given search query.
         */
        async function fetchAllPRs(token, searchQuery, cursor = null) {
            const query = `
                query FetchPRs($cursor: String) {
                    search(query: "${searchQuery}", type: ISSUE, first: ${PR_PAGE_SIZE}, after: $cursor) {
                        issueCount
                        pageInfo {
                            hasNextPage
                            endCursor
                        }
                        edges {
                            node {
                                ... on PullRequest {
                                    title
                                    createdAt
                                    url
                                    repository {
                                        nameWithOwner
                                        primaryLanguage {
                                            name
                                        }
                                    }
                                    author {
                                        login
                                    }
                                    reviewThreads { totalCount } 
                                }
                            }
                        }
                    }
                    rateLimit {
                        remaining
                    }
                }
            `;
            
            let allEdges = [];
            let currentCursor = cursor;
            let totalCount = 0;
            let hasNextPage = true;

            while (hasNextPage) {
                const variables = { cursor: currentCursor };
                
                try {
                    const data = await runGraphQLQuery(token, query, variables);
                    
                    const searchResults = data.search;
                    
                    allEdges = allEdges.concat(searchResults.edges);
                    totalCount = searchResults.issueCount; 
                    currentCursor = searchResults.pageInfo.endCursor;
                    hasNextPage = searchResults.pageInfo.hasNextPage;

                } catch (error) {
                    console.error("Pagination stopped due to error:", error);
                    hasNextPage = false;
                }
            }

            return {
                edges: allEdges,
                totalCount: totalCount
            };
        }
        
        /**
         * Fetches PRs by slicing the time range into monthly chunks to bypass the 1000-item search limit.
         */
        async function fetchReviewedPRsByChunk(token, year, username) {
            const ranges = getMonthlyDateRanges(year);
            const reviewedPRs = [];
            let apiReportedTotalCount = 0; // Use to track the cumulative issueCount sum

            for (const range of ranges) {
                const monthlyQuery = `is:pr reviewed-by:${username} -author:${username} created:${range.start}..${range.end}`;
                
                // Note: We use the pagination logic on the monthly query itself
                const monthlyResult = await fetchAllPRs(token, monthlyQuery);
                
                reviewedPRs.push(...monthlyResult.edges);
                
                // CRITICAL FIX: Sum the totalCount (issueCount) from all monthly chunks to get the accurate API total.
                apiReportedTotalCount += monthlyResult.totalCount; 
                
                if (monthlyResult.edges.length > 0 && monthlyResult.edges.length === 1000) {
                    console.warn(`Warning: Monthly chunk for ${range.start}..${range.end} hit 1000 limit. Data may be incomplete. Consider slicing by week.`);
                }
            }

            return {
                edges: reviewedPRs,
                // The totalCount is now the cumulative sum of the issueCount from all monthly chunks.
                totalCount: apiReportedTotalCount 
            };
        }


        /**
         * Fetches PR and Commit data from GitHub using GraphQL.
         */
        async function fetchGitHubData(token, username, year) {
            const { dateOnlyStart, dateOnlyEnd, dateTimeStart, dateTimeEnd } = getCurrentYearDates(year);
            const dateRangeSearch = `created:${dateOnlyStart}..${dateOnlyEnd}`;
            
            // --- OPTIMIZATION: Concurrently fetch independent data blocks ---
            const totalsAndAuthoredPromises = Promise.all([
                // 1. Fetch Totals and Commit Contributions
                runGraphQLQuery(token, `
                    query {
                        user(login: "${username}") {
                            contributionsCollection(from: "${dateTimeStart}", to: "${dateTimeEnd}") {
                                totalCommitContributions
                                commitContributionsByRepository(maxRepositories: 50) {
                                    repository {
                                        nameWithOwner
                                        isFork
                                    }
                                    contributions {
                                        totalCount
                                    }
                                }
                            }
                        }
                        rateLimit {
                            cost
                            limit
                            remaining
                            resetAt
                        }
                    }
                `),
                // 2. Fetch ALL PRs Authored (Merged only, Paginated)
                fetchAllPRs(token, `is:pr is:merged author:${username} ${dateRangeSearch}`)
            ]);

            const [nonPaginatedData, authoredPRData] = await totalsAndAuthoredPromises;

            const contributions = nonPaginatedData.user.contributionsCollection;
            const rateLimit = nonPaginatedData.rateLimit;
            
            // 3. Fetch ALL PRs Reviewed (Paginated + Chunked)
            const reviewedPRData = await fetchReviewedPRsByChunk(token, year, username);
            
            // --- 4. Split Reviewed PRs in Client-Side ---
            // The totalReviewedCount is the sum of all monthly API issueCounts.
            const totalReviewedCount = reviewedPRData.totalCount; 
            const { reviewedHuman, reviewedBot } = splitReviewedPrs(reviewedPRData.edges);

            // Return the necessary data structure for caching and rendering
            return {
                contributions: contributions,
                authored: authoredPRData,
                reviewedHuman: { edges: reviewedHuman, totalCount: reviewedHuman.length }, // Sample size length
                reviewedBot: { edges: reviewedBot, totalCount: reviewedBot.length },     // Sample size length
                totalReviewedCount: totalReviewedCount, // <-- Use API's true count here for table accuracy
                rateLimit: rateLimit
            };
        }

        // --- Modal Interaction ---

        /**
         * Shows the modal populated with the list of PRs.
         */
        function showPrListModal(title, prs, totalCount) {
            modalTitle.textContent = `${title} (${prs.length} displayed)`;
            prListContainer.innerHTML = ''; 
            
            if (prs.length === 0) {
                prListContainer.innerHTML = '<p class="text-center text-gray-500 py-4">No Pull Requests found for this category.</p>';
            } else {
                prs.forEach(pr => {
                    const node = pr.node;
                    const language = pr.node.repository?.primaryLanguage?.name || 'Unknown';
                    const repoName = pr.node.repository?.nameWithOwner || 'Unknown Repository';
                    const date = formatReadableDate(node.createdAt);
                    const authorLogin = node.author?.login || 'N/A';
                    
                    const reviewThreadCount = node.reviewThreads ? node.reviewThreads.totalCount : 0;
                    
                    const isAutogenerated = BOT_USERNAMES.includes(authorLogin.toLowerCase());
                    
                    const itemHtml = `
                        <a href="${node.url}" target="_blank" class="block p-4 border border-gray-200 rounded-lg hover:bg-blue-50 transition duration-150">
                            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center">
                                <span class="font-semibold text-gray-800 break-words max-w-full sm:max-w-xs md:max-w-md">${node.title}</span>
                                <span class="text-xs text-gray-500 mt-1 sm:mt-0 whitespace-nowrap">${date}</span>
                            </div>
                            <div class="flex items-center text-sm mt-1 space-x-3">
                                <span class="text-blue-600 font-medium">${repoName}</span>
                                <span class="bg-gray-100 text-gray-600 px-2 py-0.5 rounded-full text-xs">${language}</span>
                                ${reviewThreadCount > 0 ? `<span class="bg-amber-100 text-amber-800 px-2 py-0.5 rounded-full text-xs">${reviewThreadCount} replies</span>` : ''}
                                ${isAutogenerated ? `<span class="bg-red-100 text-red-800 px-2 py-0.5 rounded-full text-xs">Reviewed (Autogenerated): ${authorLogin}</span>` : `<span class="bg-green-100 text-green-800 px-2 py-0.5 rounded-full text-xs">Author: ${authorLogin}</span>`}
                            </div>
                        </a>
                    `;
                    prListContainer.insertAdjacentHTML('beforeend', itemHtml);
                });
            }

            prListModal.classList.remove('hidden');
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.add('hidden');
        }
        window.closeModal = closeModal;
        
        function showPatInfoModal() {
            patInfoModal.classList.remove('hidden');
        }
        window.showPatInfoModal = showPatInfoModal;
        
        // --- Event Handlers for Charts ---
        
        /**
         * Universal wrapper for Chart.js click events that pulls elements from the event object.
         * @param {Event} event The native click event.
         * @param {Chart} chartInstance The Chart.js instance.
         */
        function handleChartClickWrapper(event, chartInstance) {
            if (!chartInstance) return; 

            // Get the elements clicked
            const elements = chartInstance.getElementsAtEventForMode(
                event,
                'nearest',
                'intersect',
                true
            );

            // Determine which specific handler to call based on the chart ID
            const chartId = chartInstance.canvas.id;

            if (elements.length > 0) {
                switch (chartId) {
                    case 'prPieChart':
                        handleMainPRChartClick(event, elements, chartInstance);
                        break;
                    case 'languagePieChart':
                        handleAuthoredLanguageChartClick(event, elements, chartInstance);
                        break;
                    case 'reviewedLanguagePieChart':
                        handleReviewedLanguageChartClick(event, elements, chartInstance);
                        break;
                    case 'reviewedBotLanguagePieChart': // NEW HANDLER
                        handleReviewedBotLanguageChartClick(event, elements, chartInstance);
                        break;
                    case 'commentBarChart':
                        handleCommentDistributionChartClick(event, elements, chartInstance);
                        break;
                }
            }
        }
        window.handleChartClickWrapper = handleChartClickWrapper;


        /**
         * Handles clicks on the primary pie chart segments.
         */
        function handleMainPRChartClick(event, elements, chart) {
            const clickedIndex = elements[0].index;
            const label = chart.data.labels[clickedIndex];
            
            let prs = [];
            let totalCount = 0;

            if (label === 'PRs Authored') {
                prs = prDataCache.authored;
                totalCount = chart.data.datasets[0].data[clickedIndex];
            } else if (label === 'PRs Reviewed') {
                prs = prDataCache.reviewedHuman;
                totalCount = chart.data.datasets[0].data[clickedIndex];
            } else if (label === 'PRs Reviewed (Autogenerated)') {
                prs = prDataCache.reviewedBot;
                totalCount = chart.data.datasets[0].data[clickedIndex];
            }

            showPrListModal(label, prs, totalCount);
        }

        /**
         * Handles clicks on the Authored Language pie chart segments.
         */
        function handleAuthoredLanguageChartClick(event, elements, chart) {
            const clickedIndex = elements[0].index;
            const language = chart.data.labels[clickedIndex];
            
            // Filter the entire authored PR list by the clicked language
            const filteredPrs = prDataCache.authored.filter(pr => {
                const prLanguage = pr.node.repository?.primaryLanguage?.name || 'No Primary Language';
                return prLanguage === language;
            });

            showPrListModal(`PRs Authored in ${language}`, filteredPrs, filteredPrs.length);
        }

        /**
         * Handles clicks on the Reviewed (Human) Language pie chart segments.
         */
        function handleReviewedLanguageChartClick(event, elements, chart) {
            const clickedIndex = elements[0].index;
            const language = chart.data.labels[clickedIndex];
            
            // Filter the human reviewed PR list by the clicked language
            const filteredPrs = prDataCache.reviewedHuman.filter(pr => {
                const prLanguage = pr.node.repository?.primaryLanguage?.name || 'No Primary Language';
                return prLanguage === language;
            });

            showPrListModal(`PRs Reviewed in ${language}`, filteredPrs, filteredPrs.length);
        }

        /**
         * Handles clicks on the Reviewed (Bot) Language pie chart segments.
         */
        function handleReviewedBotLanguageChartClick(event, elements, chart) {
            const clickedIndex = elements[0].index;
            const language = chart.data.labels[clickedIndex];
            
            // Filter the bot reviewed PR list by the clicked language
            const filteredPrs = prDataCache.reviewedBot.filter(pr => {
                const prLanguage = pr.node.repository?.primaryLanguage?.name || 'No Primary Language';
                return prLanguage === language;
            });

            showPrListModal(`PRs Reviewed (Autogenerated) in ${language}`, filteredPrs, filteredPrs.length);
        }
        
        /**
         * Handles clicks on the Comment Distribution bar chart segments.
         */
        function handleCommentDistributionChartClick(event, elements, chart) {
            const clickedIndex = elements[0].index;
            const bucketLabel = chart.data.labels[clickedIndex];
            
            // Filter the entire authored PR list based on the review thread count bucket
            const filteredPrs = prDataCache.authored.filter(pr => {
                const node = pr.node;
                const replyCount = node.reviewThreads ? node.reviewThreads.totalCount : 0;

                if (bucketLabel === '0') {
                    return replyCount === 0;
                } else if (bucketLabel === '20+') {
                    return replyCount > 20;
                } else {
                    // Handle ranges like '1-5', '6-10', etc.
                    const [minStr, maxStr] = bucketLabel.split('-');
                    const min = parseInt(minStr);
                    const max = parseInt(maxStr);
                    return replyCount >= min && replyCount <= max;
                }
            });

            showPrListModal(`PRs Authored with ${bucketLabel} review replies`, filteredPrs, filteredPrs.length);
        }


        // --- Charting and UI Rendering ---

        /**
         * Draws fallback text when no data is available for a chart.
         */
        function drawNoDataFallback(ctx, title) {
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            ctx.font = '16px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#6B7280'; // Gray 500
            ctx.fillText(title, ctx.canvas.width / 2, ctx.canvas.height / 2 - 10);
            ctx.fillText("No data available for the selected year.", ctx.canvas.width / 2, ctx.canvas.height / 2 + 15);
        }
        
        // --- IMPORTANT: Chart.js needs Datalabels registered globally for configurations to work ---
        Chart.register(ChartDataLabels);

        /**
         * Renders or updates the Pie Chart for PRs Authored vs. PRs Reviewed.
         */
        function renderChart(authoredCount, reviewedHumanCount, reviewedBotCount, year) {
            const canvas = document.getElementById('prPieChart');
            const ctx = canvas ? canvas.getContext('2d') : null;

            if (!ctx) {
                console.error("Failed to get 2D rendering context for Chart 1.");
                showMessage("Dashboard generated data, but failed to draw Chart 1.", 'error');
                return;
            }
            
            const total = authoredCount + reviewedHumanCount + reviewedBotCount;
            const chartTitle = `PRs Authored vs. Reviewed (${year})`;
            
            summaryTitle.textContent = `${year} Activity Summary`;
            totalSummary.textContent = total > 0 
                ? `Total PR Activity: ${total}`
                : `No PR activity found.`;

            if (prChart) {
                prChart.destroy(); 
            }
            
            // Exit early if no data
            if (total === 0) {
                drawNoDataFallback(ctx, chartTitle);
                return; 
            }

            const data = {
                labels: ['PRs Authored', 'PRs Reviewed', 'PRs Reviewed (Autogenerated)'],
                datasets: [{
                    label: 'PR Activity',
                    data: [authoredCount, reviewedHumanCount, reviewedBotCount],
                    backgroundColor: [
                        '#EAB308', // Amber (Authored)
                        '#14B8A6',  // Teal (Reviewed Human)
                        '#0EA5E9'   // Sky Blue (Reviewed Autogenerated)
                    ],
                    hoverOffset: 8
                }]
            };
            
            const config = {
                type: 'pie',
                data: data,
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false, 
                    layout: { 
                        padding: {
                            top: 0, 
                            bottom: 0
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom', // MOVED TO BOTTOM
                            labels: { 
                                color: '#1f2937',
                                padding: 5 // Default padding
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    if (label) {
                                        let value = context.parsed;
                                        let percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                    return '';
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartTitle, 
                            color: '#1D4ED8',
                            font: { size: 16 },
                            padding: {
                                top: 10,
                                bottom: 40 // INCREASED PADDING
                            }
                        },
                        // Display labels INSIDE the segments
                        datalabels: {
                            color: '#fff', 
                            formatter: (value, context) => {
                                const total = context.dataset.data.reduce((sum, count) => sum + count, 0);
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${value} (${percentage}%)`; 
                            },
                            font: { weight: 'bold', size: 14 },
                            anchor: 'center', 
                            align: 'center',  
                            offset: 0, 
                            display: (context) => {
                                // Only display if value is > 0
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        }
                    }
                }
            };

            prChart = new Chart(ctx, config);
        }

        /**
         * Renders or updates the Language Pie Chart for PRs Authored.
         */
        function renderAuthoredLanguageChart(languageCounts, year) {
            const canvas = document.getElementById('languagePieChart');
            const ctx = canvas ? canvas.getContext('2d') : null;

            if (!ctx) {
                console.error("Failed to get 2D rendering context for Chart 2.");
                return;
            }
            
            const sortedLanguages = Object.entries(languageCounts)
                .sort(([, a], [, b]) => b - a);

            let labels = sortedLanguages.map(([name]) => name);
            let dataValues = sortedLanguages.map(([, count]) => count);
            let total = dataValues.reduce((sum, count) => sum + count, 0);
            const chartTitle = `PRs Authored Language Breakdown (${year})`;

            languageSummary.textContent = total > 0 
                ? `PRs Authored Language Breakdown (${total} PRs)` 
                : `No PRs authored with primary language found.`; 

            if (languageChart) {
                languageChart.destroy();
            }
            
            // Exit early if no data
            if (total === 0) {
                drawNoDataFallback(ctx, chartTitle);
                return; 
            }

            const chartColors = [
                '#EF4444', '#3B82F6', '#10B981', '#F59E0B', '#6366F1', '#EC4899', '#A855F7', '#6B7280',
            ];
            const backgroundColors = labels.map((_, index) => chartColors[index % chartColors.length]);

            const data = {
                labels: labels,
                datasets: [{
                    label: 'PRs Authored Language Count',
                    data: dataValues,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8
                }]
            };

            const config = {
                type: 'pie',
                data: data,
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { 
                        padding: {
                            top: 0, 
                            bottom: 0
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom', // MOVED TO BOTTOM
                            labels: { 
                                color: '#1f2937',
                                padding: 5 // Default padding
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    
                                    if (label) {
                                        let value = context.parsed;
                                        let percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                    return '';
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartTitle,
                            color: '#1D4ED8',
                            font: { size: 16 },
                            padding: {
                                bottom: 40 // INCREASED PADDING
                            }
                        },
                        // Display labels OUTSIDE with line
                        datalabels: {
                            color: '#1f2937', 
                            formatter: (value, context) => {
                                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                                return `${value} (${percentage}%)`; 
                            },
                            font: { weight: 'bold', size: 12 },
                            anchor: 'end',
                            align: 'end',
                            offset: 4, 
                            display: (context) => {
                                // Only display if value is > 0
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        }
                    }
                }
            };


            languageChart = new Chart(ctx, config);
        }

        /**
         * Renders or updates the Language Pie Chart for PRs Reviewed (Human).
         */
        function renderReviewedLanguageChart(languageCounts, year, totalAPICount) {
            const canvas = document.getElementById('reviewedLanguagePieChart');
            const ctx = canvas ? canvas.getContext('2d') : null;

            if (!ctx) {
                console.error("Failed to get 2D rendering context for Chart 3.");
                return;
            }
            
            const sortedLanguages = Object.entries(languageCounts)
                .sort(([, a], [, b]) => b - a);

            let labels = sortedLanguages.map(([name]) => name);
            let dataValues = sortedLanguages.map(([, count]) => count);
            let sampleTotal = dataValues.reduce((sum, count) => sum + count, 0);
            const chartTitle = `PRs Reviewed Language Breakdown (${year})`;

            let summaryText = `PRs Reviewed Language Breakdown (${sampleTotal} PRs analyzed)`;
            
            // REMOVED WARNING CHECK: if (totalAPICount > sampleTotal) { ... }

            if (sampleTotal === 0) {
                 summaryText = `No PRs reviewed with primary language found.`;
            }

            reviewedLanguageSummary.innerHTML = summaryText; 

            if (reviewedLanguageChart) {
                reviewedLanguageChart.destroy();
            }

            // Exit early if no data
            if (sampleTotal === 0) {
                drawNoDataFallback(ctx, chartTitle);
                return; 
            }

            // Using a distinct color palette
            const chartColors = [
                '#059669', '#3730A3', '#D97706', '#8B5CF6', '#F43F5E', '#1D4ED8', '#6EE7B7', '#9CA3AF',
            ];
            const backgroundColors = labels.map((_, index) => chartColors[index % chartColors.length]);


            const data = {
                labels: labels,
                datasets: [{
                    label: 'PRs Reviewed Language Count',
                    data: dataValues,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8
                }]
            };

            const config = {
                type: 'pie',
                data: data,
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { 
                        padding: {
                            top: 0, 
                            bottom: 0
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom', // MOVED TO BOTTOM
                            labels: { 
                                color: '#1f2937',
                                padding: 5 // Default padding
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    if (label) {
                                        let value = context.parsed;
                                        let percentage = sampleTotal > 0 ? ((value / sampleTotal) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                    return '';
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartTitle,
                            color: '#1D4ED8',
                            font: { size: 16 },
                            padding: {
                                bottom: 40 // INCREASED PADDING
                            }
                        },
                        // Display labels OUTSIDE with line
                        datalabels: {
                            color: '#1f2937', 
                            formatter: (value, context) => {
                                const percentage = sampleTotal > 0 ? ((value / sampleTotal) * 100).toFixed(1) : 0;
                                return `${value} (${percentage}%)`; 
                            },
                            font: { weight: 'bold', size: 12 },
                            anchor: 'end',
                            align: 'end',
                            offset: 4, 
                            display: (context) => {
                                // Only display if value is > 0
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        }
                    }
                }
            };

            reviewedLanguageChart = new Chart(ctx, config);
        }

        /**
         * Renders or updates the Language Pie Chart for PRs Reviewed (Autogenerated). (NEW CHART)
         */
        function renderReviewedBotLanguageChart(languageCounts, year, totalAPICount) {
            const canvas = document.getElementById('reviewedBotLanguagePieChart');
            const ctx = canvas ? canvas.getContext('2d') : null;

            if (!ctx) {
                console.error("Failed to get 2D rendering context for Chart 5.");
                return;
            }
            
            const sortedLanguages = Object.entries(languageCounts)
                .sort(([, a], [, b]) => b - a);

            let labels = sortedLanguages.map(([name]) => name);
            let dataValues = sortedLanguages.map(([, count]) => count);
            let sampleTotal = dataValues.reduce((sum, count) => sum + count, 0);
            const chartTitle = `PRs Reviewed (Autogenerated) Language Breakdown (${year})`;


            let summaryText = `PRs Reviewed (Autogenerated) Language Breakdown (${sampleTotal} PRs analyzed)`;
            
            // REMOVED WARNING CHECK: if (totalAPICount > sampleTotal) { ... }

            if (sampleTotal === 0) {
                 summaryText = `No autogenerated PRs reviewed with primary language found.`;
            }
            
            reviewedBotLanguageSummary.innerHTML = summaryText;

            if (reviewedBotLanguageChart) {
                reviewedBotLanguageChart.destroy();
            }

            // Exit early if no data
            if (sampleTotal === 0) {
                drawNoDataFallback(ctx, chartTitle);
                return; 
            }

            // Using a distinct color palette
            const chartColors = [
                '#FF7F50', '#8A2BE2', '#32CD32', '#FFD700', '#4682B4', '#DA70D6', '#20B2AA', '#A9A9A9',
            ];
            const backgroundColors = labels.map((_, index) => chartColors[index % chartColors.length]);


            const data = {
                labels: labels,
                datasets: [{
                    label: 'PRs Reviewed Autogenerated Language Count',
                    data: dataValues,
                    backgroundColor: backgroundColors,
                    hoverOffset: 8
                }]
            };

            const config = {
                type: 'pie',
                data: data,
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: { 
                        padding: {
                            top: 0, 
                            bottom: 0
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'bottom', // MOVED TO BOTTOM
                            labels: { 
                                color: '#1f2937',
                                padding: 5 // Default padding
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    if (label) {
                                        let value = context.parsed;
                                        let percentage = sampleTotal > 0 ? ((value / sampleTotal) * 100).toFixed(1) : 0;
                                        return `${label}: ${value} (${percentage}%)`;
                                    }
                                    return '';
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartTitle,
                            color: '#1D4ED8',
                            font: { size: 16 },
                            padding: {
                                bottom: 40 // INCREASED PADDING
                            }
                        },
                        // Display labels OUTSIDE with line
                        datalabels: {
                            color: '#1f2937', 
                            formatter: (value, context) => {
                                const percentage = sampleTotal > 0 ? ((value / sampleTotal) * 100).toFixed(1) : 0;
                                return `${value} (${percentage}%)`; 
                            },
                            font: { weight: 'bold', size: 12 },
                            anchor: 'end',
                            align: 'end',
                            offset: 4, 
                            display: (context) => {
                                // Only display if value is > 0
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        }
                    }
                }
            };

            reviewedBotLanguageChart = new Chart(ctx, config);
        }

        /**
         * Renders or updates the Bar Chart for PRs Authored Discussion Volume.
         */
        function renderCommentDistributionChart(dataObject, year) {
            const canvas = document.getElementById('commentBarChart');
            const ctx = canvas ? canvas.getContext('2d') : null;

            if (!ctx) {
                console.error("Failed to get 2D rendering context for Chart 4.");
                return;
            }
            
            const chartTitle = `PRs Authored Review Reply Distribution (${year})`;

            commentSummary.textContent = dataObject.totalPRsAnalyzed > 0 
                ? `Total PRs Authored analyzed: ${dataObject.totalPRsAnalyzed}` 
                : `No PRs Authored found for analysis.`;

            if (commentChart) {
                commentChart.destroy();
            }
            
            // Exit early if no data
            if (dataObject.totalPRsAnalyzed === 0) {
                drawNoDataFallback(ctx, chartTitle);
                return; 
            }

            const data = {
                labels: dataObject.labels,
                datasets: [{
                    label: 'Number of PRs',
                    data: dataObject.counts,
                    backgroundColor: '#0EA5E9', // Sky Blue
                    borderColor: '#0284C7',
                    borderWidth: 1
                }]
            };

            const config = {
                type: 'bar',
                data: data,
                plugins: [ChartDataLabels],
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y', // Horizontal bars
                    layout: { 
                        padding: {
                            top: 0, 
                            bottom: 0
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of PRs',
                                color: '#1f2937'
                            },
                            ticks: {
                                color: '#1f2937'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#1f2937'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                             callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.formattedValue}`;
                                }
                            }
                        },
                        title: {
                            display: true,
                            text: chartTitle,
                            color: '#1D4ED8',
                            font: { size: 16 },
                            padding: {
                                top: 10,
                                bottom: 20 // Increased bottom padding for the title
                            }
                        },
                        datalabels: {
                            color: '#1f2937', 
                            anchor: 'end',
                            align: 'end',
                            offset: 4,
                            formatter: (value) => value > 0 ? value : '',
                            font: { weight: 'bold', size: 12 },
                            display: (context) => {
                                // Only display if value is > 0
                                return context.dataset.data[context.dataIndex] > 0;
                            }
                        }
                    }
                }
            };


            commentChart = new Chart(ctx, config);
        }

        /**
         * Renders the Overall Contribution Totals table.
         */
        function renderOverallTotals(data, authoredCount, reviewedHumanCount, reviewedBotCount, totalReviewedAPICount) {
            // Calculate the combined total reviewed PRs for the chart/sample
            const totalReviewedCombinedSample = reviewedHumanCount + reviewedBotCount;
            
            const table = `
                <table class="min-w-full divide-y divide-gray-200">
                    <thead class="bg-gray-50">
                        <tr>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Metric</th>
                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Total</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200 text-gray-800">
                        <tr>
                            <td class="px-6 py-4 whitespace-nowrap font-medium text-blue-600">Total PRs Authored</td>
                            <td class="px-6 py-4 whitespace-nowrap">${authoredCount}</td>
                        </tr>
                        <tr>
                            <td class="px-6 py-4 whitespace-nowrap font-medium text-teal-600">Total PRs Reviewed</td>
                            <td class="px-6 py-4 whitespace-nowrap">${reviewedHumanCount}</td>
                        </tr>
                        <tr>
                            <td class="px-6 py-4 whitespace-nowrap font-medium text-sky-600">Total PRs Reviewed (Autogenerated)</td>
                            <td class="px-6 py-4 whitespace-nowrap">${reviewedBotCount}</td>
                        </tr>
                        <tr class="bg-gray-100 font-bold">
                            <td class="px-6 py-4 whitespace-nowrap">Total PRs Reviewed (Combined)</td>
                            <td class="px-6 py-4 whitespace-nowrap">${totalReviewedAPICount}</td>
                        </tr>
                        <tr>
                            <td class="px-6 py-4 whitespace-nowrap font-medium">Total Commits</td>
                            <td class="px-6 py-4 whitespace-nowrap">${data.contributions.totalCommitContributions}</td>
                        </tr>
                    </tbody>
                </table>
            `;
            overallTotalsTable.innerHTML = table;
        }

        /**
         * Renders the Commit Contributions Per Repository table.
         */
        function renderRepoCommits(contributionsByRepo, currentUsername) {
            if (!contributionsByRepo || contributionsByRepo.length === 0) {
                repoCommitTable.innerHTML = '<p class="text-center text-gray-500 py-4">No commit contributions found.</p>';
                return;
            }
            
            // Filter: Exclude repositories owned by the current user
            const externalContributions = contributionsByRepo
                .filter(item => {
                    const owner = item.repository.nameWithOwner.split('/')[0];
                    return owner.toLowerCase() !== currentUsername.toLowerCase();
                });

            const sortedContributions = externalContributions
                // Sort by commit count descending
                .sort((a, b) => b.contributions.totalCount - a.contributions.totalCount);

            const tableRows = sortedContributions.map(item => {
                const totalCount = item.contributions.totalCount;
                const repoName = item.repository.nameWithOwner;
                
                return `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">${repoName}</td>
                        <td class="px-6 py-4 whitespace-nowrap text-sm text-right">
                            ${totalCount}
                        </td>
                    </tr>
                `;
            }).join('');

            const table = `
                <div class="overflow-x-auto rounded-lg border border-gray-200 shadow-sm">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Repository</th>
                                <th scope="col" class="px-6 py-3 text-right text-xs font-medium text-gray-500 uppercase tracking-wider">Total Commits</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200 text-gray-800">
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
            `;
            repoCommitTable.innerHTML = table;
        }

        /**
         * Converts the current dashboard view (charts and tables) into a downloadable PDF/DOC report.
         */
        async function downloadDashboardReport() {
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Generating...';
            showMessage("Generating print-ready report...", 'info');
            
            const year = yearSelector.value;
            const username = usernameInput.value;
            const reportTitle = `GitHub Activity Report - ${username} (${year})`;

            // Get IDs of all chart containers (the parent .card div)
            // Need to adjust to account for the new fifth chart (reviewedBotLanguagePieChart)
            const chartContainers = [
                document.getElementById('prPieChart').closest('.card'),
                document.getElementById('languagePieChart').closest('.card'),
                document.getElementById('reviewedLanguagePieChart').closest('.card'),
                document.getElementById('reviewedBotLanguagePieChart').closest('.card'), // NEW CHART
                document.getElementById('commentBarChart').closest('.card')
            ];
            
            let chartImagesHtml = '';

            // Map chart containers to image promises
            const imagePromises = chartContainers.map(container => {
                if (!container || container.style.display === 'none' || container.parentElement.classList.contains('hidden')) {
                     return Promise.resolve(null);
                }
                
                // Use html2canvas to capture the entire chart container, including legend/title
                return html2canvas(container, {
                    scale: 2, // Higher resolution
                    backgroundColor: '#ffffff', // Ensure white background
                    useCORS: true,
                    allowTaint: true
                }).then(canvas => {
                    return canvas.toDataURL('image/png');
                }).catch(e => {
                    console.error("Error capturing canvas:", e);
                    return null;
                });
            });

            // Wait for all chart images to be generated
            const images = await Promise.all(imagePromises);

            images.forEach((dataUrl, index) => {
                if (dataUrl) {
                    const chartNames = [
                        'PRs Authored vs. Reviewed',
                        'PRs Authored Language Breakdown',
                        'PRs Reviewed Language Breakdown',
                        'PRs Reviewed (Autogenerated) Language Breakdown', // NEW NAME
                        'PRs Authored Review Reply Distribution'
                    ];
                    
                    const chartTitle = chartNames[index] || `Chart ${index + 1}`;
                    
                    // Use standard block display for DOC readability
                    chartImagesHtml += `
                        <div style="width: 48%; display: inline-block; margin-right: 1.5%; vertical-align: top; margin-bottom: 20px;">
                            <h4 style="font-size: 1.1rem; font-weight: 600; margin-bottom: 10px; color: #1D4ED8;">${chartTitle}</h4>
                            <img src="${dataUrl}" style="max-width: 100%; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);" alt="${chartTitle}">
                        </div>
                    `;
                }
            });

            // Get table content (clone and remove Tailwind classes for clean HTML export)
            const overallTableContent = overallTotalsTable.innerHTML.replace(/class="[^"]*"/g, '');
            const commitTableContent = repoCommitTable.innerHTML.replace(/class="[^"]*"/g, '');
            
            // Define print-friendly styles for the generated document
            const reportStyle = `
                <style>
                    /* Print/DOC-Friendly Styles */
                    body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; padding: 30px; background-color: #ffffff; }
                    h1 { color: #1D4ED8; font-size: 2rem; border-bottom: 2px solid #D1D5DB; padding-bottom: 10px; margin-bottom: 20px; }
                    h2 { color: #1f2937; font-size: 1.5rem; margin-top: 30px; margin-bottom: 15px; }
                    h4 { color: #1D4ED8; font-size: 1.1rem; margin-top: 10px; margin-bottom: 10px; }
                    .charts-grid { display: flex; flex-wrap: wrap; justify-content: space-between; page-break-inside: avoid; }
                    .report-table-wrapper { margin-top: 20px; page-break-inside: avoid; }
                    
                    /* Table Styles (Added 'report-table' class to tables below) */
                    .report-table { width: 100%; border-collapse: collapse; margin-top: 10px; }
                    .report-table th, .report-table td { border: 1px solid #e5e7eb; padding: 10px; text-align: left; }
                    .report-table th { background-color: #f9fafb; font-weight: 600; color: #4b5563; text-transform: uppercase; font-size: 0.75rem; }
                    .report-table td { background-color: #ffffff; color: #374151; font-size: 0.875rem; }
                    .report-table td:nth-child(2) { text-align: right; }
                    
                    /* Ensure images are printable and side-by-side */
                    @media print {
                        .charts-grid { display: block !important; }
                        .charts-grid > div {
                            width: 90% !important; 
                            display: block !important;
                            margin: 0 auto 20px auto;
                        }
                    }
                </style>
            `;
            
            // Generate the final HTML document content
            const htmlContent = `
                <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>${reportTitle}</title>
                    ${reportStyle}
                </head>
                <body>
                    <h1>${reportTitle}</h1>
                    <p><strong>Generated By:</strong> GitHub Activity Dashboard</p>
                    <p><strong>Date Generated:</strong> ${new Date().toLocaleString()}</p>

                    <h2>Chart Summary</h2>
                    <div class="charts-grid">
                        ${chartImagesHtml}
                    </div>

                    <h2>Overall Contribution Totals</h2>
                    <div class="report-table-wrapper">
                        ${overallTableContent.replace(/<table/g, '<table class="report-table"')}
                    </div>

                    <h2>Commit Contributions (Top 50 Repositories)</h2>
                    <div class="report-table-wrapper">
                        ${commitTableContent.replace(/<table/g, '<table class="report-table"')}
                    </div>
                    
                    <p style="margin-top: 30px; font-size: 0.9rem; color: #6b7280;">Note: Commit counts include all contributions to external repositories for the selected year.</p>
                </body>
                </html>
            `;

            // Open in a new window and trigger print dialog
            const printWindow = window.open('', '_blank');
            if (printWindow) {
                printWindow.document.write(htmlContent);
                printWindow.document.close();
                printWindow.focus();
                
                // Use a short timeout to ensure the DOM is fully rendered before printing
                setTimeout(() => {
                    printWindow.print();
                    // printWindow.close(); // Optional: close the window after print attempt
                }, 500); 
            } else {
                 showMessage("Error: Pop-up blocked. Please enable pop-ups to generate the report.", 'error');
            }

            clearMessage();
            showMessage("Print dialog opened. Select 'Save as PDF' to download the report.", 'success');
            downloadBtn.disabled = false;
            downloadBtn.textContent = 'Download Report';
        }
        window.downloadDashboardReport = downloadDashboardReport;


        // --- Main Controller ---

        async function generateDashboard() {
            clearMessage();
            dashboardArea.classList.add('hidden');
            downloadBtn.classList.add('hidden'); // Hide download button until successful generation
            
            const token = patInput.value.trim();
            const username = usernameInput.value.trim();
            const year = parseInt(yearSelector.value);
            
            if (!token || !username) {
                showMessage("Please enter both a valid GitHub PAT and Username.", 'error');
                return;
            }

            generateBtn.disabled = true;
            generateBtn.textContent = `Generating Dashboard for ${year}...`;

            try {
                // 1. Fetch Data
                const data = await fetchGitHubData(token, username, year);

                // 2. Update Rate Limit Display
                if (data.rateLimit) {
                    rateLimitDisplay.classList.remove('hidden');
                    rateRemainingDisplay.textContent = `${data.rateLimit.remaining} / ${data.rateLimit.limit}`;
                }

                // 3. Cache PR Data
                const authoredCount = data.authored.totalCount;
                const reviewedHumanCount = data.reviewedHuman.totalCount; 
                const reviewedBotCount = data.reviewedBot.totalCount; 
                const commitContributionsByRepo = data.contributions.commitContributionsByRepository; 
                const totalReviewedAPICount = data.totalReviewedCount; // API's true total
                
                // Set cache using edges
                prDataCache.authored = data.authored.edges;
                prDataCache.reviewedHuman = data.reviewedHuman.edges;
                prDataCache.reviewedBot = data.reviewedBot.edges;

                // 4. Process Data for Charts
                const authoredLanguageCounts = processLanguageData(prDataCache.authored);
                const reviewedLanguageCounts = processLanguageData(prDataCache.reviewedHuman);
                const reviewedBotLanguageCounts = processLanguageData(prDataCache.reviewedBot); // NEW DATA
                const commentDistributionData = processCommentDistribution(prDataCache.authored); // Authored PRs only
                
                // 5. Render All UI Components (using a slight delay to ensure canvas rendering)
                renderOverallTotals(data, authoredCount, reviewedHumanCount, reviewedBotCount, totalReviewedAPICount);
                renderRepoCommits(commitContributionsByRepo, username); // PASSING USERNAME HERE
                
                // RENDER FIVE CHARTS
                renderChart(authoredCount, reviewedHumanCount, reviewedBotCount, year);
                renderAuthoredLanguageChart(authoredLanguageCounts, year);
                
                // Pass true total to reviewed charts for discrepancy warning
                const reviewedSampleTotal = reviewedHumanCount + reviewedBotCount;

                renderReviewedLanguageChart(reviewedLanguageCounts, year, totalReviewedAPICount); 
                renderReviewedBotLanguageChart(reviewedBotLanguageCounts, year, totalReviewedAPICount);
                
                renderCommentDistributionChart(commentDistributionData, year);

                dashboardArea.classList.remove('hidden');
                downloadBtn.classList.remove('hidden'); // Show download button
                showMessage("Dashboard successfully generated! Ready to download.", 'success');
                
                // --- HISTORY UPDATE LOGIC (GUARD AGAINST BLOB URLS) ---
                if (!window.location.href.startsWith('blob:')) {
                    const url = new URL(window.location.href);
                    url.searchParams.set('username', username);
                    window.history.replaceState({}, '', url.toString());
                }
                // ------------------------------------------------------
                
            } catch (error) {
                console.error(error);
                let message = `Dashboard generation failed: ${error.message}`;
                if (error.message.includes('401 Unauthorized')) {
                    message = "Authentication Failed: Check your GitHub PAT validity and permissions (read:user scope needed).";
                } else if (error.message.includes('rate limit')) {
                    message = "GitHub Rate Limit Exceeded. Please try again after the reset time.";
                }
                showMessage(message, 'error');
                
                // Reset cache on failure
                prDataCache = { authored: [], reviewedHuman: [], reviewedBot: [] };
            } finally {
                generateBtn.disabled = false;
                generateBtn.textContent = 'Generate Dashboard';
            }
        }

        // --- Initial Setup ---
        window.onload = function () {
            populateYearSelector();

            // Logic to check for URL query parameter 'username'
            const urlParams = new URLSearchParams(window.location.search);
            const urlUsername = urlParams.get('username');

            if (urlUsername) {
                // Overwrite the default value with the URL parameter if it exists
                usernameInput.value = urlUsername;
            }
            
            // Add Esc key listener to close modals
            document.addEventListener('keydown', function(event) {
                if (event.key === 'Escape') {
                    if (!prListModal.classList.contains('hidden')) {
                        closeModal('prListModal');
                    } else if (!patInfoModal.classList.contains('hidden')) {
                        closeModal('patInfoModal');
                    }
                }
            });
        }
    </script>
</body>
</html>